Spring核心技术
前置课程要求: 请各位小伙伴完成《JavaWeb》篇《Java9-17新特性》篇 再来学习此章节📖

建议: 💦对Java开发还不是很熟悉的同学 最好先花费半个月到一个月时间大量地去编写小项目 不推荐一口气学完
后面的内容相比前面的内容几乎是降维打击 一口气学完很容易忘记之前所学的基础知识 尤其是JavaSE阶段的内容

不同于2021版本SSM教程 本章为重制版本 学习的Spring框架版本为: 6.0 ⚠

恭喜各位顺利进入到SSM(Spring+SpringMVC+Mybatis)阶段的学习 也算是成功出了Java新手村 由于前面我们已经学习过Mybatis了 因此 本章节的时间安排相比之前会更短一些
从这里开始 很多的概念理解起来就稍微有一点难度了 因为你们没有接触过企业开发场景 很难体会到那种思想带来的好处
甚至到后期接触到的几乎都是基于云计算和大数据理论实现的框架(当下最热门最前沿的技术)逐渐不再是和计算机基础相关联 而是和怎么高效干活相关了

在JavaWeb阶段 我们已经学习了如何使用Java进行Web应用程序开发 我们现在已经具有搭建Web网站的能力 但是 我们在开发的过程中 发现存在诸多的不便
在最后的图书管理系统编程实战中 我们发现虽然我们思路很清晰 知道如何编写对应的接口 但是这样的开发效率 实在是太慢了
并且对于对象创建的管理 存在诸多的不妥之处 因此 我们要去继续学习更多的框架技术 来简化和规范我们的Java开发

Spring就是这样的一个框架(文档: https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/core.html#spring-core) 它就是为了简化开发而生
它是轻量级Ioc和AOP的容器框架 主要是针对于Bean的生命周期进行管理的轻量级容器 并且它的生态已经发展得极为庞大 那么 首先一问 什么是IoC和AOP 什么又是Bean呢? 不要害怕
这些概念只是听起来满满的高级感 实际上没有多高级(很多东西都是这样 名字听起来很牛 实际上只是一个很容易理解的东西🤔)

IoC容器基础
Spring框架最核心的其实它的IoC容器 这是我们开启Spring学习的第一站

IoC理论介绍
在我们之前的图书管理系统Web应用程序中 我们发现整个程序其实是依靠各个部分相互协作 共同完成一个操作 比如要展示借阅信息列表 那么首先需要使用Servlet进行请求和响应数据处理
然后请求的数据全部交给对应的Service(业务层)来处理 当Service发现要从数据库中获取数据时 再向对应的Mapper发起请求

它们之间就像连接再一起的齿轮 谁也离不开谁

    https://img-blog.csdnimg.cn/img_convert/ac00363a3f1e09d452a151ed08796a60.png

就像一个团队 每个人的分工都很明确 流水线上的一套操作必须环环相扣 这是一种高度耦合的体系

虽然这样的体系逻辑非常清晰 整个流程也能够让人快速了解 但是这样存在一个很严重的问题 我们现在的时代实际上是一个软件项目高速迭代的时代 我们发现很多App三天两头隔三差五地就更新
而且是什么功能当下最火 就马不停蹄地进行跟进开发 因此 就很容易出现 之前写好的代码 实现的功能 需要全部推翻 改成新的功能
那么我们就不得不去修改某些流水线上的模块 但是这样一修改 会直接导致整个流水线的引用关系大面积更新

比如下面的情况:

                    class A {
                        private List<B> list;
                        public test(B b) {
                            return null;
                        }
                    }

                    class C {
                        public C(B b) {}
                    }

                    class B {}

可以看到 A和C在大量地直接使用B 但是某一天 这个B的实现已经过时了 此时来了个把功能实现的更好的D 我们需要用这个新的类来完成业务了:

    https://img-blog.csdnimg.cn/img_convert/52c2d169f427828b85c61884201cfa57.png

可以看到 因为类之间的关联性太强了 会开始大面积报错 所有之前用了B的类 得挨个进行修改 全都改成D 这简直是灾难啊😫

包括我们之前JavaWeb阶段编写的实战项目 如果我们不想用某个Service实现类了 我想使用其他的实现类用不同的逻辑做这些功能
那么这个时候 我们只能每个类都去挨个进行修改 当项目特别庞大时 光是改个类名导致的连带修改就够你改一天了

因此 高耦合度带来的缺点是很明显的 也是现代软件开发中很致命的问题 如果要改善这种情况 我们只能将各个模块进行解耦 让各个模块之间的依赖性不再那么地强
也就是说 Service的实现类 不再由我们决定 而是让程序自己决定 所有的实现类对象 全部交给程序来管理 所有对象之间的关系 也由程序来动态决定 这样就引入了IoC理论

IOC是Inversion of Control的缩写 翻译为: "控制反转" 把复杂系统分解成相互合作的对象 这些对象类通过封装以后 内部实现对外部是透明的 从而降低了解决问题的复杂度 而且可以灵活地被重用和扩展

    https://img-blog.csdnimg.cn/img_convert/200a3ad15f71b3621de1d6cbde692e9b.png

我们可以将对象交给IoC容器进行管理 比如当我们需要一个接口的实现时 由它根据配置文件来决定到底给我们哪一个实现类 这样 我们就可以不用再关心我们要去使用哪一个实现类了 我们只需要关心
给到我的一定是一个可以正常使用的实现类 能用就完事了 反正接口定义了啥 我只管调 这样 我们就可以放心地让一个人去写视图层的代码 一个人去写业务层的代码 开发效率那是高的一批啊🚀

还是之前的代码 但是有了IoC容器加持之后:

                    public static void main(String[] args) {
                        A a = new A();
                        a.test(IoC.getBean(Service.class)); // 瞎编写一个容器类 但是是那个意思
                        // 比如现在在IoC容器中管理的Service的实现是B 那么我们从里面拿到的Service实现就是B
                    }

                    class A {
                        private List<Service> list; // 一律使用Service 具体实现由IoC容器提供
                        public Service test(Service b) {
                            return null;
                        }
                    }

                    interface Service() {} // 使用Service做一个顶层抽象

                    class B implements Service {} // B依然是具体实现类 并交给IoC容器管理

当具体实现类发生修改时 我们同样只需要将新的实现类交给IoC容器管理 这样我们无需修改之前的任何代码:

                    interface Service{ }

                    class D implements Service{}   // 现在实现类变成了D 但是之前的代码并不会报错

这样 即使我们的底层实现类发生了修改 也不会导致与其相关联的类出现错误 而进行大面积修改 通过定义抽象+容器管理的形式 我们就可以将原有的强关联解除

高内聚 低耦合 是现代软件的开发的设计目标 而Spring框架就给我们提供了这样的一个IoC容器进行对象的的管理 一个由Spring IoC容器实例化 组装和管理的对象⚙ 我们称其为Bean